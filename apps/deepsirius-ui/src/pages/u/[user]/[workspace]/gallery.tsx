"use client";

import { useEffect, useMemo, useState } from "react";
import ErrorPage from "next/error";
import Link from "next/link";
import { useRouter } from "next/router";
import dayjs from "dayjs";
import { ArrowLeftIcon } from "lucide-react";
import { useQueryState } from "nuqs";
import { type Edge, type Node } from "reactflow";
import { toast } from "sonner";
import type { NodeData, NodeStatus } from "~/hooks/use-store";
import { AvatarDrop } from "~/components/avatar-dropdown";
import {
  Tensorboard,
  TensorboardLink,
  ViewRemoteImages,
  ViewRemoteLog,
} from "~/components/gallery-views";
import { Layout } from "~/components/layout";
import { Button } from "~/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "~/components/ui/tooltip";
import NodeIcon from "~/components/workboard/node-components/node-icon";
import { StatusBadge } from "~/components/workboard/status-badge";
import { useStore, useStoreActions } from "~/hooks/use-store";
import { useUser } from "~/hooks/use-user";
import { checkStatusRefetchInterval } from "~/lib/constants";
import { defaultSlurmLogPath } from "~/lib/utils";
import { api } from "~/utils/api";

function Gallery({ user, workspace }: { user: string; workspace: string }) {
  const [nodeId] = useQueryState("nodeId");
  const [view] = useQueryState("view");
  const { nodes } = useStore();
  const selectedNode = useMemo(
    () => nodes.find((node) => node.id === nodeId),
    [nodes, nodeId],
  );

  if (!selectedNode || !selectedNode.type) {
    return (
      <div className="flex h-screen w-screen flex-col bg-light-ocean dark:bg-dark-ocean">
        <div className="flex h-[8%] w-full flex-row justify-between">
          <BoardLink user={user} workspace={workspace} />
          <AvatarDrop />
        </div>
        <div className="flex h-[92%] flex-row">
          <p className="text-center text-slate-300">No node selected</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex h-screen w-screen flex-col bg-light-ocean dark:bg-dark-ocean">
      <div className="flex h-[8%] w-full flex-row justify-between">
        <BoardLink user={user} workspace={workspace} />
        <AvatarDrop />
      </div>
      <div className="flex h-[92%] w-full gap-4 p-2">
        <div className="h-fit w-1/5 rounded-lg border p-2 shadow-lg">
          <SidePanelContent node={selectedNode} />
        </div>
        <div className="h-full w-4/5">
          <GalleryView view={view} node={selectedNode} />
        </div>
      </div>
    </div>
  );
}

function getLogPath(node: Node<NodeData>) {
  const workspacePath = node.data.workspacePath;
  const jobId = node.data.jobId;
  const jobName = node.type ? `deepsirius-${node.type}` : "";
  return defaultSlurmLogPath({
    workspacePath,
    jobId,
    jobName,
  });
}

function SidePanelContent({ node }: { node: Node<NodeData> }) {
  const [status, setStatus] = useState<NodeStatus>(node.data.status);
  const [view, setView] = useQueryState("view");

  if (!node.data) return null;
  if (!node.type) return null;

  return (
    <TooltipProvider>
      <div className="flex flex-col space-y-2 p-4">
        <NodeInfo
          type={node.type}
          nodeData={node.data}
          status={status}
          setStatus={setStatus}
        />
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              onClick={() => void setView("log-output")}
              variant={(view === "log-output" && "default") || "outline"}
            >
              Output Logs
            </Button>
          </TooltipTrigger>
          <TooltipContent>
            <p className="text-muted-foreground">
              View the logs of the job execution.
            </p>
          </TooltipContent>
        </Tooltip>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button
              onClick={() => void setView("log-err")}
              variant={(view === "log-err" && "default") || "outline"}
            >
              Error Logs
            </Button>
          </TooltipTrigger>
          <TooltipContent>
            <p className="text-muted-foreground">
              View the error logs of the job execution.
            </p>
          </TooltipContent>
        </Tooltip>
        <Tooltip>
          <TooltipTrigger asChild>
            <span tabIndex={0}>
              <Button
                onClick={() => void setView("preview-imgs")}
                variant={(view === "preview-imgs" && "default") || "outline"}
                disabled={!["augmentation"].includes(node.type)}
                className="!w-full"
              >
                Preview Images
              </Button>
            </span>
          </TooltipTrigger>
          <TooltipContent>
            <p className="text-muted-foreground">
              Preview the images generated by the augmentation process.
              {node.type !== "augmentation" &&
                " Only available for augmentation nodes."}
            </p>
          </TooltipContent>
        </Tooltip>
        <Tooltip>
          <TooltipTrigger asChild>
            <span tabIndex={0}>
              <TensorboardLink
                logdir={getLogPath(node).out}
                disabled={
                  !(node.type === "network" || node.type === "finetune") ||
                  status !== "busy"
                }
                onClick={() => void setView("tensorboard")}
              />
            </span>
          </TooltipTrigger>
          <TooltipContent>
            <p className="text-muted-foreground">
              View the tensorboard of the training. Only available for busy
              network or finetune nodes.
            </p>
          </TooltipContent>
        </Tooltip>
      </div>
    </TooltipProvider>
  );
}

function NodeInfo({
  type,
  nodeData,
  status,
  setStatus,
}: {
  type: string;
  nodeData: NodeData;
  status: NodeStatus;
  setStatus: (status: NodeStatus) => void;
}) {
  const [message, setMessage] = useState<string | undefined>(nodeData.message);
  const nodeName = useMemo(() => {
    if (!type) return undefined;
    switch (type) {
      case "dataset":
        return nodeData.datasetData?.name;
      case "augmentation":
        return nodeData.augmentationData?.name;
      case "network":
        return nodeData.networkData?.label;
      case "finetune":
        const sourceLabel =
          nodeData.finetuneData?.sourceNetworkLabel ?? undefined;
        return sourceLabel ? `${sourceLabel} finetune` : "finetune";
      case "inference":
        const outputPath = nodeData.inferenceData?.outputPath ?? "";

        return outputPath;
      default:
        return undefined;
    }
  }, [type, nodeData]);

  const { data: jobData } = api.job.checkStatus.useQuery(
    { jobId: nodeData.jobId ?? "" },
    {
      refetchOnMount: false,
      enabled: status === "busy" && !!nodeData.jobId,
      refetchInterval: checkStatusRefetchInterval,
      refetchIntervalInBackground: true,
    },
  );

  useEffect(() => {
    if (!jobData) return;
    if (status === "success" || status === "error") return;
    if (jobData.jobStatus === "COMPLETED") {
      const date = dayjs().format("YYYY-MM-DD HH:mm:ss");
      setStatus("success");
      setMessage(
        `Job ${nodeData.jobId ?? "Err"} finished successfully in ${date}`,
      );
    } else if (
      jobData.jobStatus === "FAILED" ||
      jobData.jobStatus?.includes("CANCELLED")
    ) {
      const date = dayjs().format("YYYY-MM-DD HH:mm:ss");
      setStatus("error");
      setMessage(`Job ${nodeData.jobId ?? "Err"} failed in ${date}`);
    } else if (jobData.jobStatus === "RUNNING") {
      const date = dayjs().format("YYYY-MM-DD HH:mm:ss");
      setStatus("busy");
      setMessage(`Job ${nodeData.jobId ?? "Err"} last checked at ${date}`);
    }
  }, [jobData, status, nodeData.jobId, setStatus]);

  return (
    <div className="flex flex-col space-y-2">
      <div className="flex items-center justify-between">
        <div className="flex flex-row gap-2">
          <NodeIcon nodeType={type} />
          <p className="text-md font-semibold">{type}</p>
        </div>
        <StatusBadge status={status} />
      </div>
      <p className="text-md text-wrap">{nodeName ?? "node"}</p>
      <p className="text-muted-foreground">{message}</p>
    </div>
  );
}

function BoardLink({ user, workspace }: { user: string; workspace: string }) {
  return (
    <Link
      href={`/u/${user}/${workspace}`}
      className="flex flex-row items-center p-4 hover:underline"
    >
      <ArrowLeftIcon className="mr-2 h-4 w-4" />
      {"Back to"}
      <p className="ml-1 text-blue-800 dark:text-blue-500">{`"${workspace}"`}</p>
    </Link>
  );
}

function GalleryView({
  view,
  node,
}: {
  view: string | null;
  node: Node<NodeData>;
}) {
  const jobId = node.data.jobId;
  const { out, err } = getLogPath(node);
  switch (view) {
    case "log-output":
      if (!jobId) return <p>Job Id not found</p>;
      if (!node.type) return <p>Node type not found</p>;
      return <ViewRemoteLog path={out} />;
    case "log-err":
      if (!jobId) return <p>Job Id not found</p>;
      if (!node.type) return <p>Node type not found</p>;
      return <ViewRemoteLog path={err} />;
    case "preview-imgs":
      if (!node.data?.augmentationData)
        return <p>Augmentation data not found</p>;
      return (
        <ViewRemoteImages path={node.data.augmentationData.remotePreviewPath} />
      );
    case "tensorboard":
      return <Tensorboard logdir={out} />;
    default:
      return (
        <div className="flex h-full w-3/4 items-center justify-center rounded-lg border border-dashed">
          <p className="h-1/2 text-center text-muted-foreground">
            Select a view
          </p>
        </div>
      );
  }
}

export default function GalleryRouter() {
  const { initNodes, initEdges, setWorkspaceInfo, resetStore } =
    useStoreActions();
  const { workspaceInfo } = useStore();
  const storeWorkspace = workspaceInfo?.name;
  const router = useRouter();
  const sessionUser = useUser();

  const { user, workspace } = router.query; // Assuming 'user' and 'workspace' are dynamic segments
  const routeWorkspace = typeof workspace === "string" ? workspace : "";
  const isGalleryRoute = router.pathname.includes("/gallery");

  const workspaceChanged = routeWorkspace !== storeWorkspace;

  const { data, error, isLoading } = api.db.getWorkspaceByName.useQuery(
    {
      name: routeWorkspace,
    },
    {
      enabled: workspaceChanged && !!routeWorkspace,
      refetchOnMount: false,
    },
  );

  useEffect(() => {
    if (!routeWorkspace) return;
    if (workspaceChanged && !!data?.path) {
      if (storeWorkspace) {
        toast.info(`Leaving workspace ${storeWorkspace}`);
      }
      toast.info(`Switching to workspace ${routeWorkspace}`);
      resetStore();
      setWorkspaceInfo({
        name: data.name,
        path: data.path,
      });
      if (!!data.state) {
        const { nodes, edges } = JSON.parse(data.state) as {
          nodes: Node<NodeData>[];
          edges: Edge[];
        };
        if (nodes) initNodes(nodes);
        if (edges) initEdges(edges);
      }
    }
  }, [
    data,
    workspaceChanged,
    resetStore,
    setWorkspaceInfo,
    initNodes,
    initEdges,
    storeWorkspace,
    routeWorkspace,
    workspace,
  ]);

  const workspaceLoaded = !workspaceChanged && workspaceInfo && routeWorkspace;
  const searchingWorkspace = workspaceChanged && !error;

  if (!sessionUser) {
    return <ErrorPage statusCode={401} />;
  }

  if (sessionUser.name !== user) {
    return <ErrorPage statusCode={403} />;
  }

  if (workspaceLoaded)
    return <Gallery user={sessionUser.name} workspace={workspaceInfo.name} />;

  if (searchingWorkspace) {
    return (
      <Layout>
        <div className="flex flex-row items-center justify-center gap-4">
          <p className="text-center text-slate-300">Loading workspace...</p>
        </div>
      </Layout>
    );
  }

  if (error) {
    console.error("error", error);
    return <ErrorPage statusCode={500} title={error.message} />;
  }

  console.error("Hey! Forbidden state!", {
    workspaceChanged,
    routeWorkspace,
    isGalleryRoute,
    data,
    isLoading,
    error,
  });

  return <ErrorPage statusCode={404} />;
}
